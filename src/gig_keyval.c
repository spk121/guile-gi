
// Autogenerated file
#define _XOPEN_SOURCE 700       /* for strdup */
#include <stdlib.h>
#include <string.h>
#include "gig_keyval.h"

FunctionInfoTable *
function_cache_new(void)
{
    FunctionInfoTable *kv = calloc(1, sizeof(FunctionInfoTable));
    kv->entries = calloc(20, sizeof(FunctionInfoItem));
    kv->alloc = 20;
    kv->len = 0;
    return kv;
}

void
function_cache_free(FunctionInfoTable *kv, FunctionInfoTableKeyFreeFunc keyfree, FunctionInfoTableValFreeFunc valfree)
{
    for (int i = 0; i < kv->len; i++) {
        if (keyfree)
            keyfree(kv->entries[i].key);
        if (valfree)
            valfree(kv->entries[i].val);
    }
    free(kv->entries);
    free(kv);
}

static int
function_cache_comparison(const void *pA, const void *pB)
{
    const FunctionInfoItem *A = pA;
    const FunctionInfoItem *B = pB;
    return (A->key > B->key) - (A->key < B->key);
}

void
function_cache_add_entry(FunctionInfoTable *kv, GIFunctionInfo * key, GigFunction * val)
{
    FunctionInfoItem A;
    A.key = key;
    A.val = val;

    void *pB;
    pB = bsearch(&A, kv->entries, kv->len, sizeof(FunctionInfoItem), function_cache_comparison);
    if (pB == NULL) {
        if (kv->alloc == kv->len) {
            kv->alloc += 20;
            kv->entries = realloc(kv->entries, kv->alloc * sizeof(FunctionInfoItem));
        }
        kv->entries[kv->len].key = key;
        kv->entries[kv->len].val = val;
        kv->len++;
        qsort(kv->entries, kv->len, sizeof(FunctionInfoItem), function_cache_comparison);
    }
    else {
        FunctionInfoItem *B = pB;
        B->val = val;
    }
}

GigFunction *
function_cache_find_entry(FunctionInfoTable *kv, GIFunctionInfo * key)
{
    void *pB;
    FunctionInfoItem A;
    A.key = key;
    A.val = (GigFunction *) 0;

    pB = bsearch(&A, kv->entries, kv->len, sizeof(FunctionInfoItem), function_cache_comparison);
    if (pB == NULL)
        return (GigFunction *) 0;

    return ((FunctionInfoItem *) pB)->val;
}

int
function_cache_size(FunctionInfoTable *kv)
{
    return kv->len;
}
GtypeHash *
gtype_hash_new(void)
{
    GtypeHash *kv = calloc(1, sizeof(GtypeHash));
    kv->entries = calloc(20, sizeof(GtypeItem));
    kv->alloc = 20;
    kv->len = 0;
    return kv;
}

void
gtype_hash_free(GtypeHash *kv, GtypeHashKeyFreeFunc keyfree, GtypeHashValFreeFunc valfree)
{
    for (int i = 0; i < kv->len; i++) {
        if (keyfree)
            keyfree(kv->entries[i].key);
        if (valfree)
            valfree(kv->entries[i].val);
    }
    free(kv->entries);
    free(kv);
}

static int
gtype_hash_comparison(const void *pA, const void *pB)
{
    const GtypeItem *A = pA;
    const GtypeItem *B = pB;
    return (A->key > B->key) - (A->key < B->key);
}

void
gtype_hash_add_entry(GtypeHash *kv, GType key, scm_t_bits val)
{
    GtypeItem A;
    A.key = key;
    A.val = val;

    void *pB;
    pB = bsearch(&A, kv->entries, kv->len, sizeof(GtypeItem), gtype_hash_comparison);
    if (pB == NULL) {
        if (kv->alloc == kv->len) {
            kv->alloc += 20;
            kv->entries = realloc(kv->entries, kv->alloc * sizeof(GtypeItem));
        }
        kv->entries[kv->len].key = key;
        kv->entries[kv->len].val = val;
        kv->len++;
        qsort(kv->entries, kv->len, sizeof(GtypeItem), gtype_hash_comparison);
    }
    else {
        GtypeItem *B = pB;
        B->val = val;
    }
}

scm_t_bits
gtype_hash_find_entry(GtypeHash *kv, GType key)
{
    void *pB;
    GtypeItem A;
    A.key = key;
    A.val = (scm_t_bits) 0;

    pB = bsearch(&A, kv->entries, kv->len, sizeof(GtypeItem), gtype_hash_comparison);
    if (pB == NULL)
        return (scm_t_bits) 0;

    return ((GtypeItem *) pB)->val;
}

int
gtype_hash_size(GtypeHash *kv)
{
    return kv->len;
}
ScmHash *
scm_hash_new(void)
{
    ScmHash *kv = calloc(1, sizeof(ScmHash));
    kv->entries = calloc(20, sizeof(ScmItem));
    kv->alloc = 20;
    kv->len = 0;
    return kv;
}

void
scm_hash_free(ScmHash *kv, ScmHashKeyFreeFunc keyfree, ScmHashValFreeFunc valfree)
{
    for (int i = 0; i < kv->len; i++) {
        if (keyfree)
            keyfree(kv->entries[i].key);
        if (valfree)
            valfree(kv->entries[i].val);
    }
    free(kv->entries);
    free(kv);
}

static int
scm_hash_comparison(const void *pA, const void *pB)
{
    const ScmItem *A = pA;
    const ScmItem *B = pB;
    return (A->key > B->key) - (A->key < B->key);
}

void
scm_hash_add_entry(ScmHash *kv, scm_t_bits key, GType val)
{
    ScmItem A;
    A.key = key;
    A.val = val;

    void *pB;
    pB = bsearch(&A, kv->entries, kv->len, sizeof(ScmItem), scm_hash_comparison);
    if (pB == NULL) {
        if (kv->alloc == kv->len) {
            kv->alloc += 20;
            kv->entries = realloc(kv->entries, kv->alloc * sizeof(ScmItem));
        }
        kv->entries[kv->len].key = key;
        kv->entries[kv->len].val = val;
        kv->len++;
        qsort(kv->entries, kv->len, sizeof(ScmItem), scm_hash_comparison);
    }
    else {
        ScmItem *B = pB;
        B->val = val;
    }
}

GType
scm_hash_find_entry(ScmHash *kv, scm_t_bits key)
{
    void *pB;
    ScmItem A;
    A.key = key;
    A.val = (GType) 0;

    pB = bsearch(&A, kv->entries, kv->len, sizeof(ScmItem), scm_hash_comparison);
    if (pB == NULL)
        return (GType) 0;

    return ((ScmItem *) pB)->val;
}

int
scm_hash_size(ScmHash *kv)
{
    return kv->len;
}


