
// Autogenerated file
#define _XOPEN_SOURCE 700       /* for strdup */
#include <stdlib.h>
#include <string.h>
#include "gig_strval.h"

NameHash *
name_hash_new(void)
{
    NameHash *kv = calloc(1, sizeof(NameHash));
    kv->entries = calloc(20, sizeof(NameItem));
    kv->alloc = 20;
    kv->len = 0;
    return kv;
}

void
name_hash_free(NameHash *kv, NameHashValFreeFunc valfree)
{
    for (int i = 0; i < kv->len; i++) {
        free(kv->entries[i].str);
        if (valfree)
            valfree(kv->entries[i].val);
    }
    free(kv->entries);
    free(kv);
}

static int
name_hash_comparison(const void *pA, const void *pB)
{
    const NameItem *A = pA;
    const NameItem *B = pB;
    return strcmp(A->str, B->str);
}

void
name_hash_add_entry(NameHash *kv, const char *str, SCM val)
{
    NameItem A;
    A.str = str;
    A.val = val;

    void *pB;
    pB = bsearch(&A, kv->entries, kv->len, sizeof(NameItem), name_hash_comparison);
    if (pB == NULL) {
        if (kv->alloc == kv->len) {
            kv->alloc += 20;
            kv->entries = realloc(kv->entries, kv->alloc * sizeof(NameItem));
        }
        kv->entries[kv->len].str = strdup(str);
        kv->entries[kv->len].val = val;
        kv->len++;
        qsort(kv->entries, kv->len, sizeof(NameItem), name_hash_comparison);
    }
    else {
        NameItem *B = pB;
        B->val = val;
    }
}

SCM
name_hash_find_entry(NameHash* kv, const char *str)
{
    void *pB;
    NameItem A;
    A.str = str;
    A.val = (SCM) 0;

    pB = bsearch(&A, kv->entries, kv->len, sizeof(NameItem), name_hash_comparison);
    if (pB == NULL)
        return (SCM) 0;

    return ((NameItem *) pB)->val;
}

int
name_hash_size(NameHash * kv)
{
    return kv->len;
}



