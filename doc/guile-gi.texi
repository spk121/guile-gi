\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile-gi.info
@settitle Guile GI
@c %**end of header
@syncodeindex fn cp
@include version.texi

@copying
Copyright @copyright{} 2018, 2019 Michael L. Gran

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end copying

@titlepage
@title Guile GI
@subtitle Version @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@c @ifnottex
@node Top
@top Guile GI

This manual is for Guile GI @value{VERSION}.
@c @end ifnottex

@menu
* Preface::
* Getting Started::
* Tutorials::
* Reference Guide::
* Further Resources and Contact Info::
* GNU Free Documentation License::
* Index::

@detailmenu
--- The Detailed Node Listing ---

Getting Started

* Installation::
* Guile-GI and Typelibs::
* Sample Applications::

Sample Applications

* Empty Window::

Tutorials

* GObject Types and Guile Types::
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::

Reference Guide

* Typelib Introspection::
* Typelib Documentation::
* GObject Types::
* GType::
* GObject Methods::
* GObject Signals::
* GObject Properties::
* Custom GObjects::              Defining new GObject classes
* Enums and Flags::
* Utilities::
* More Stuff::

@end detailmenu
@end menu

@node Preface
@unnumbered Preface

Guile GI is a Guile package that hopes to provide access for
GObject-based libraries such as GTK+, GLib, WebKitGTK+ and many more.

It supports GNU/Linux, and has only been tested with Guile-2.2. Guile
GI is licensed under the LGPLv2.1+. This documentation is licensed under
the FDLv1.3+.

If you want to write a Guile application for GNOME or a Guile GUI
application using GTK+, then Guile GI (when it is finished) will be
the way to go.

@node Getting Started
@chapter Getting Started

@quotation Warning
Guile-GI is still in its experimental phase and even so, this documentation
describes features of vastly different age. Don't be too surprised if something breaks.
@end quotation

In the followings section we will walk you through all steps from installation
to writing applications.

@menu
* Installation::
* Guile-GI and Typelibs:: How to load libraries through GI
* Sample Applications::
@end menu

@node Installation
@section Installation

In some happy future, you might be able to get this from whatever method
your operating system normally uses to download free software.

If you are trying to build this from the Git repository, use
@command{git clone} to copy the tree onto your computer. After closing
the repository, you need to run @command{autoreconf} to generate a
@file{configure} file.

If you are building from a @file{guile-gi.zip} file or a
@file{guile-gi.tar.gz}, unpack the file.

From there, running @command{configure}, then @command{make}, then
@command{sudo make install} will give you a running system.

In the file archives, look for files named @file{INSTALL} for detailed
instructions.

@node Guile-GI and Typelibs
@section Guile-GI and Typelibs

To understand how Guile-GI works, one needs to distinguish between
itself and the bindings it creates.

@itemize
@item
Guile-GI itself is a library that allows you to parse @code{typelib}
files, which describe code modules.  It has a handful of procedures for
inspecting @code{typelib} files as well as some helper procedures for
dynamically creating procedures and types.
@item
When Guile-GI is used, it creates procedures, variables, and types
according to the instructions in the @code{typelib} files.  These are
created @emph{at runtime} as Guile loads them from the @code{typelib}
file.
@end itemize

In order to make use of the latter, you must load a typelib through
Guile-GI in one form or another.  The easiest and recommended way of
doing so is @code{use-typelibs}, as shown below.

@example
(use-modules (gi))
(use-typelibs ("GLib" "2.0") ("Gtk" "3.0"))
@end example

@code{use-typelibs} works quite similar to @code{use-modules} and is in
fact implemented in terms of it. The only difference in syntax is, that
instead of a list of symbols describing a module, you have a list of
exactly two strings, the first being the name of the typelib and the
second being the version.

Semantically, however, the difference to @code{use-modules} is bigger.
Internally, Guile-GI creates modules for the typelibs as needed -- in
this example these modules would be @code{(%gi GLib-2.0)} and @code{(%gi
Gtk-3.0)} -- and loads the entire typelib into them. This approach has
two major drawbacks.
@enumerate
@item
Guile-GI has to load the entire typelib. For large typelibs, such as
GTK, this takes a lot of time.  Instead, you may want to only load
parts, e.g. just GtkApplication and GtkWindow to significantly speed up
loading.  @code{(gi repository)} has primitives to facilitate exactly
that. @xref{Typelib Introspection}.

@item
Even though Guile-GI internally uses modules, these modules are not
available to the user in any meaningful way.  Even another
@code{use-modules} on them actually leads to undefined behaviour.  It
may load the module if it has already been defined somewhere else, but
it might also throw an error, claiming that no code for the module could
be found.  This is to be expected, given that the modules are not backed
by actual files.

If you need to use @code{use-modules} (e.g. as a part of a
@code{define-module}), you need to write the module yourself.  As a
convenience, @code{(gi repository)} defines @code{typelib->module},
which loads a typelib into a module and also adds all loaded
functionality to its public interface.  Use it as in the following
example.
@example
@include gtk-3.scm

;; additional code you might want to add and export
@end example
@end enumerate

Loading typelibs alone might be all you need if you have perfect
knowledge of all the libraries you are going to use and an intuitive
understanding of how they are mapped to Scheme procedures.  Chances are,
however, that you do not.  In this case, it might be useful to generate
some documentation. @xref{Typelib Documentation}.

Upon installation of Guile-GI, we install a script called
@code{gi-gtkdoc}, that can be invoked through @code{guild}.  You may
also want to create a @file{guile-procedures.txt} file for use in the
REPL.  We currently have no script for that, but one can easily be
written.  The following for example exports all the documentation for
GObject-2.0.

@example
#!/path/to/guile
(use-modules (gi documentation))

(let ((%typelib (typelib "GObject" "2.0"))
      (%gir (false-if-exception (gir "GObject" "2.0")))
      (%doc '()))
  (set! %doc (parse %typelib %doc))
  (close %typelib)
  (when %gir
    (set! %doc (parse %gir %doc))
    (close %gir))
  (->guile-procedures.txt %doc))
@end example

Use shell pipes to redirect the output into a file, preferably one
called ``guile-procedures.txt''.  Guile will search for documentation in
such files in a few locations, including the current working directory.

@node Sample Applications
@section Sample Applications

@menu
* Empty Window::
@end menu

@node Empty Window
@subsection Empty Window
We will skillfully demonstrate the capabilities of Guile-GI by creating
an empty window with a title.  Are you excited?  Behold!

@example
@include example-1.scm
@end example

As discussed in the previous section, loading the entirety of Gtk is
slow, so we instead use primitives from @code{(gi repository)}.  In
addition, there are some functions, that we didn't yet learn about, as
well as the bindings created for @code{<GtkApplication>}, etc.

@findex make

First is @code{make}, which wraps and extends the @code{make} procedure
found in GOOPS.  @xref{GOOPS,,,guile,The Guile reference manual} for
infos about GOOPS.  In short the arguments, that would normally be used
for slot initialization are instead used to initialize properties.  This
is important, because the slots of the GOOPS object @strong{do not} map
to properties, and neither do the properties map to slots.  @code{make}
can also be used on some types, which do not derive from GObject, most
notably it can be called without any arguments to allocate boxed types.

@findex connect

Next is @code{connect}, which connects Guile procedures as handlers to
GObject signals.  Signals are roughly equal to hooks in Guile, except
that they have an invisible default handler and hence two @code{connect}
methods instead of a single @code{add-hook!} one.  Removing a connection
also requires temporarily saving the return value (which is an integer
id), so that it can be passed to @code{signal-handler-disconnect}.

Finally, we have the bindings themselves, as mentioned before.
@xref{GObject Types} on the mapping of types,
@ref{GObject Methods} on how to use methods,
@ref{GObject Signals} on how to use signals and
@ref{GObject Properties} on how to use properties.

@node Tutorials
@chapter Tutorials

@menu
* GObject Types and Guile Types::
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::
@end menu

@node GObject Types and Guile Types
@section GObject Types and Guile Types

Every time you call a GObject procedure provided by Guile-GI, the
Guile arguments need to be converted to C arguments, and the return
values need to be converted back into Guile values. For integer and
string arguments, the C to Guile conversions are straightforward; for
GObject types -- such as GTK's @code{GtkWindow} or @code{GtkButton} or
GLib's @code{GDate} -- a Guile object needs to be converted into a C
structure.  Hopefully, in normal circumstances, this conversion will
happen automatically without difficulty.

@cindex structs
@cindex unions
@cindex objects

GObject types have different categories.  Some are simple C structs and
unions.  Others are @emph{objects}, which is GObject's class hierarchy
upon which the windowing library GTK is built.

Explaining how Guile-to-C type conversion is accomplished under the
hood can be slightly confusing because there are several different
things named `type':

@enumerate
@item
the C typedef of a structure, union or object, such as @code{struct GtkWindow}
@item
the C @code{GType}, a unique integer ID that GObject libraries provide
for each C typedef'd structure, union, or object
@item
the Guile class @code{<GType>} created by Guile-GI for each GType to hold instances
of the associated C structure
@end enumerate

For example, GLib has a type @code{GDate *} which holds information
about a calendar date.  The @code{GDate *} typedef has an associated
@code{GType} integer ID.  The Guile class @code{<Date>} is created to
hold structures with that @code{GType}.  When using GLib's date
functions from Guile, instances of @code{GDate *} are held by instances
of the Guile class @code{<Date>}.

Internally to Guile-GI, all of the Guile classes for GObject structs,
objects and unions are GOOPS types that handle managing the C pointer.
The C pointer is ``hidden'' in the @code{ptr} slot of an object.

@node Threads and Concurrency
@section Threads and Concurrency
@cindex threads
@cindex concurrency

While Guile is multi-threaded, applications using Guile-GI are not fully
thread-safe.  Notably, applications using GTK or GLib's mainloop need
all rendering and mainloop activities to occur in one thread.  Also, all
calls to @code{typelib-load} need to be made from the same thread.

@node Debugging and Profiling
@section Debugging and Profiling
@cindex debugging
@cindex profiling

Guile-GI makes use of GLib's debug logging.  Running a program with the
@env{G_MESSAGES_DEBUG} environment variable set to @code{all} will
provide a full trace of the function calls in Guile-GI.  For more
information on how to take advantage of this logging, see
@uref{https://developer.gnome.org/glib/stable/glib-running.html}.

@node Application Deployment
@section Application Deployment
@cindex deployment

If you write a program in Guile-GI and wish to share it with the world,
you will need to ensure your users have all the prerequisites.

@cindex prerequisites

At a minimum, Guile-GI scripts will require that users have the
following packages.
@itemize
@item Guile
@item Guile-GI
@item libffi
@item GLib
@item GObject-Introspection aka GIRepository
@end itemize

And then, of course, a Guile-GI program will additionally require
whatever libraries its uses (GTK, WebKit2) as well as their associated
typelib files.

@cindex directory structure

A good layout for an application might be the following, though we can't
discourage you from using any other.
@example
/path/to/project
|-- doc
|-- data
|   |-- icons
|   |-- various XML files
|   `-- etc.
|-- module
|   |-- project.scm
|   `-- project
|       `-- more Scheme source files
|-- src
|   `-- C source files (optional, when depending on other libraries/non-GI functionality)
|-- test
|   `-- tests
`-- READMEs, ChangeLogs, build system stuff ...
@end example

You should be able to make use of most ``data APIs'' (such as GSettings,
GResource, GtkBuilder...), as long as the data files don't need to
reference functionality implemented in your Scheme code.  If you do find
yourself needing some of that, e.g. if you want to write a GtkBuilder
file for a custom class, consider implementing this functionality in C
and exporting it as a typelib instead.

@node Testing and Continuous Integration
@section Testing and Continuous Integration
@cindex testing
@cindex continuous integration

The distribution does contain a couple of scripts that should enable it
to be built by Travis-CI.  In the root directory, there is a
@code{.travis.yml} and a @code{Dockerfile} that work together.  The
docker container pulls the latest version of Ubuntu, and the YML file
builds the project and runs @code{make distcheck}.

@node Reference Guide
@chapter Reference Guide

The Guile GI project provides a Guile module @file{(gi)}.  The
@file{(gi)} module is an interface for dynamically creating Guile
modules for GObject-based libraries by examining the information in
their @file{.typelib} files.

@c -----------------------------------------------------------------
@menu
* Typelib Introspection::
* Typelib Documentation::
* GObject Types::
* GType::
* GObject Methods::
* GObject Signals::
* GObject Properties::
* Custom GObjects::              Defining new GObject classes
* Enums and Flags::
* Utilities::
* More Stuff::
@end menu

@c -----------------------------------------------------------------
@node Typelib Introspection
@section Typelib Introspection
@cindex typelibs
@cindex introspection

A GObject typelib file contains information on the public classes,
functions, and variables in a GObject-based library, and most
GObject-complient libraries, such as GLib and GTK, provide one.  Usually
these files are on the file system in a single directory location.  On
Fedora, for example, these files may be stored in
@file{/var/lib64/girepository-1.0}.

All functions outlined in this section are part of @code{(gi
repository)} and are not re-exported by @code{(gi)}.

@deffn Procedure require lib [version]
Forces the namespace @var{lib} to be loaded if it isn't already.
This step is required once per @var{lib} before any other functionality
of this module is used.
If @var{version} is given, loads that version, otherwise loads the latest available.

Throws an error, if the library could not be found or loaded.
@end deffn

@deffn Procedure get-search-path
This returns the current search path used to find typelib files as a list of strings.

If it returns an empty list, this indicates that it is only searching
the default typelib directory.
@end deffn

@deffn Procedure prepend-search-path! directory
Given @var{directory}, a string representation of a file system
directory, this prepends that directory to the typelib search path.

This change doesn't affect libraries loaded before it. It therefore is
advisable to put such directives at the start of a script.
@end deffn

@deffn Procedure infos lib
Fetches all top-level metadata entries of @var{lib}.
@end deffn

@deffn Procedure info lib name
Searches @var{lib} for an entry with name @var{name} and returns it.
Throws an error, if @var{name} could not be found.
@end deffn

@deffn Procedure load (info <GBaseInfo>)
@deffnx Procedure load (info <GBaseInfo>) flags
Generates bindings for @var{info}.

@var{flags} is a logical or of @code{LOAD_METHODS}, @code{LOAD_SIGNALS},
@code{LOAD_PROPERTIES} and @code{LOAD_FIELDS}
and may be 0 or @code{LOAD_INFO_ONLY} tells @code{load}, how to handle
infos with nested information, such as structs and objects.
They enable loading of methods, signals, properties and fields respectively.
By default, all of them are loaded.

@quotation Warning
@code{LOAD_FIELDS} currently does nothing, as fields are not yet supported.
@end quotation
@end deffn

@deffn Procedure load-by-name lib name [flags]
A convenience function composing @code{info} and @code{load}.
@end deffn

@deffn Procedure typelib->module module lib [version]
Loads all infos of @var{lib} into @var{module} and adds them to its public
interface.

@var{module} may be a module or a list of symbols. If the latter is given,
it is resolved to a (potentially new) module. In either case, the resulting
module is returned.

If @var{version} is given, loads that version, otherwise loads the latest.
Throws an error, if the library could not be found or loaded.
@end deffn

@c -----------------------------------------------------------------
@node Typelib Documentation
@section Typelib Documentation

@deffn Procedure typelib lib [version] [#:require?=#t]
Open a new input port, whose contents describe the runtime bindings created
for @var{lib}. If @var{version} is given, use that version of the typelib,
otherwise the latest. If @var{require?} is true (the default), require
it first.
@end deffn

@deffn Procedure gir lib version
Open a new file input port for the GIR metadata of LIB. VERSION applies just
as with @code{typelib}, but is required.
@end deffn

@deffn Parameter gir-search-path
Search path, that @code{gir} searches GIR metadata in.
This parameter is actually defined in @code{(gi config)}.
@end deffn

@deffn Procedure parse xml [documentation]
Parse @var{xml} into a structure suitable for post-processing.
If @var{documentation} is given, use it as a base, merging the two.

@var{xml} is expected to be a string or port containing documentation in
an XML format. @var{documentation} should either be the empty list (the
default) or the result of a previous @code{parse} operation.

It should be noted, that the order in which documentations are threaded
through @code{parse} matters. The last @code{xml} ``wins'' in cases
where multiple ones fill in the same value (e.g. attributes).  Since
GIRs has more information than typelibs, you should therefore handle
typelibs first in most cases.

The result is a nodeset corresponding to the (merged) XML.  However, it
is stripped down to only contain nodes relevant for documentation (the
exact subset may be subject to change) and also contains the
non-standard @code{scheme} node for bindings created by Guile-GI.
@end deffn

@deffn Procedure ->guile-procedures.txt documentation
Display @var{documentation} in an @file{guile-procedures.txt}-esque style.
@end deffn

@deffn Procedure ->docbook documentation
Display @var{documentation} as DocBook XML.
@quotation Warning
The standard DocBook tools installable through most distributions do
not handle XML, but rather SGML.
Trying to postprocess the results of this function with them will
only end up in weird results, (potentially lots of) errors and user frustration.
Use GTK-Doc instead, either directly or through @code{xsltproc},
or use your own XSLT stylesheets.
@end quotation
@end deffn


@c -----------------------------------------------------------------
@node GObject Types
@section GObject Types
@cindex types

For integer and string arguments, the C to Guile conversions are the
obvious ones. But for the specialized GObject types, things get a bit
more complex.  GObject has three classes of custom types: structs,
unions, and objects.

@cindex unions
@cindex structs
GObject @emph{unions} and @emph{structs} are handled in Guile-GI by
creating a GOOPS type that wraps a C pointer.  Typically,
instances can be created and by GObject functions and used as
arguments, but, their contents aren't otherwise modifyiable.  GObject
unions and structs may have GObject Methods, but do not have signals
or properties. @xref{GObject Methods} for more information.

@cindex objects
GObject @emph{objects} are also stored by creating a GOOPS
type that wraps a C pointer.  Unlike GObject structs and unions, they
have more interactivity available at the Guile layer.  They have
properties that can be queried and Guile procedures can be hooked into
the GObject callback layer, which GObject calls ``signals''.

For each custom GObject type, Guile-GI creates a variable that holds
the GOOPS type.  That variable has the form @code{<TYPE>},
where TYPE is the GObject type name. To check whether an object
has a given type, use the @code{is-a?} procedure found in GOOPS, which
Guile-GI re-exports.

@example
(use-modules (gi))
(use-typelibs ("GObject" "2.0") ("Gio" "2.0"))
(is-a? (make <GApplication>) <GObject>)
;; => #t
@end example

Each GObject struct, union, or object has a place in the GObject
single-inheritance class structure.  A @code{RadioButton} is a type of
@code{Button} is a type of @code{Widget}, for example.  If you wish to
introspect a GObject's type, use @code{get-gtype} and then use the GType
procedures. @xref{GType}.

@c -----------------------------------------------------------------
@node GType
@section GType
@cindex GType

A @code{<GType>} is a Guile type, which corresponds to a @code{GType}.
A @code{GType} is basically an integer ID (an @code{<integer>} in Scheme),
that GObject uses to identify a type.

GObject has its own custom class structure.  The following procedures
provide information about how a @code{<GType>} forms part of that
class structure.

@deffn Procedure get-gtype object
Given @var{object}, a GObject struct, union, or object, this procedure
returns its GObject type as an @code{<integer>}, otherwise it returns @code{#f}.
@end deffn

@deffn Procedure gtype-get-scheme-type gtype
Given @var{gtype} of type @code{<integer>}, this procedure will return
the Scheme type that holds instances of that type.
@end deffn

@deffn Procedure gtype-get-name gtype
Given @var{gtype} of type @code{<integer>}, this procedure returns
a string with GObject's internal name for this type.  This may differ
slightly from the name that Guile-GI gives to the type.
@end deffn

@deffn Procedure gtype-get-parent gtype
@deffnx Procedure gtype-get-children gtype
These procedures return the parent type and the child types of a
specified @var{gtype}.
@end deffn

@deffn Procedure gtype-is-a? object type
Returns @code{#t} of @var{object} is an instance of a @var{type}.
@end deffn

@c -----------------------------------------------------------------
@node GObject Methods
@section GObject Methods
@cindex methods

Guile-GI exports object methods as GOOPS methods in the formats
@code{type:method} and @code{method}, where @var{type} is the type of an
object sans namespace translated into @code{kebab-case} and @var{method}
is the name of the method translated into @code{kebab-case}. For
instance @code{gtk_widget_show} is bound to both @code{widget:show} and
@code{show}.

Use whichever bindings you prefer or alternatively rename them using the
@code{#:rename} argument to @code{use-modules} or @code{use-typelibs}
respectively. Note that Guile currently warns if a binding is imported
from multiple libraries (e.g. both GLib and Gtk), but this should not
concern you in most cases, as both internally specialize the same
generic method.

@c -----------------------------------------------------------------
@node GObject Signals
@section GObject Signals
@cindex signals

GObjects have a functionality for defining and calling callback
procedures that it calls @emph{signals}.  Note that these signals have
nothing to do with Unix signals like @code{SIGTERM}.

@findex connect
To hook a callback procedure to an object's signal, use the
@code{connect} procedure. Consider the following example.

@example
(define (activate app)
   ...
   )

(define activate-signal (make <signal> #:name "activate"))

(connect app              ; A GObject
         activate-signal  ; A <signal> object
         activate)        ; A procedure to call when emitted
@end example

In that example, the caller is attaching a procedure named
@code{activate} to the object @code{app}'s ``activate'' signal.  When
the gobject object calls all the callback procedures attached to its
``activate'' signal it will call this @code{activate} procedure.

When a callback procedure is called it may receives some arguments
from the caller and some from user data.  In the example, @code{activate}
is supposed to take a single argument.
This argument -- @code{app} -- is supplied by the caller, as are all
arguments to signals.

@deffn Procedure connect obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect obj (signal <signal>) (detail <symbol>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (detail <symbol>) (handler <procedure>)
Hooks @var{handler} to emissions of @var{signal}.  If @var{detail} is
supplied, only emissions in which the detail matches it are considered.

@code{connect-after} works like @code{connect}, except that the handler
is run @emph{after} the main handling code.
@end deffn

Signal objects can also be used to emit signals. Note that you shouldn't
normally do this when using objects of types, that you didn't define,
and even when using objects of types, that you did define, you should
only emit the signals that you defined for that object (and perhaps the
``notify'' signal when using explicit notification).

@defspec signal obj [detail] [args...]
Emits the @var{signal} signal of @var{obj} with @var{detail} and @var{args}.
Note, that the interpretation of @var{detail} depends on whether or not @var{signal} is detailed.
If it is, @var{detail} needs to be a symbol, that will be translated to the detail of the emission.
If it is not, it is considered the first argument and will be consed with @var{args} to form
an argument list.
@end defspec

Signals have several slots, that can be bound on creation time (and
reassigned freely, since they are proper GOOPS objects).  When
connecting signals, only @var{name} needs to be supplied.  When using
them as proper signals, at least @var{return-type} needs to be given as
well.

@defvr Slot name
The name of the signal.
A string.
@end defvr
@defvr Slot return-type
The return type of the signal.
A @code{<GType>} or integer.
@end defvr
@defvr Slot param-types
The parameter types of the signal.
A list of @code{<GType>}s or integers.
@end defvr
@defvr Slot accumulator
A procedure, called with two arguments @var{seed} and @var{current} and
produces up to two output values.  If it produces no output value,
@var{seed} is left unchanged and signal handling continues.  If it
produces one output value, @var{seed} is set to that value and signal
handling continues.  If it produces two output values, @var{seed} is set
to the second output value and signal handling stops if the first is
@code{#f}.  If at any time @var{seed} would be set to an incorrect value
or more than two values are returned signal handling is aborted.
@end defvr
@defvr Slot flags
Signal flags, a logical or of  one or more of
@code{SIGNAL_RUN_FIRST}, @code{SIGNAL_RUN_LAST},
@code{SIGNAL_RUN_CLEANUP}, @code{SIGNAL_NO_RECURSE}, etc.
@c TODO: refer to the GObject manual
@end defvr

@c -----------------------------------------------------------------
@node GObject Properties
@section GObject Properties

GObject objects may have one or more properties, which are variables
attached to the object that may be gotten or set.  GObject properties
usually have C-like types.  Remember that GObject objects are instances
of a class that may have a parent class, and each parent class may one
or more properties. So, for example, if the object is a radio button,
you may get or set properties that apply specifically to radio buttons,
or generic buttons, or generic widgets.

@findex <GParam>

In Guile-GI, properties come in two flavours.  The basic building block
are objects derived from @code{G_TYPE_PARAM} alias @code{<GParam>}.
These can be created via introspected methods found in the
@code{GObject} library.  They are enhanced so that they can work as
procedures with setter.  Given an arbitrary property @code{prop},
@code{(prop obj)} will fetch the corresponding property, whereas
@code{(set! (prop obj) val)} will set it.

The other flavour are GOOPS accessors.  These are used for introspected
properties, so that the name may also overlap with a method or a signal
of a different type. Other than that, they behave no different from
@code{<GParam>}s -- in fact, they work by constructing a @code{<GParam>}
and using their getters and setters.

@node Custom GObjects
@section Defining new GObject classes
@cindex GObjects
@cindex classes, GObject

@findex register-type
Usually any GObjects you use will be created by procedures such as
@code{window:new}, and those GObject types will have been predefined in
the typelib. But, it is possible to make custom GObject object classes
using the @code{register-type} procedure.

Bear in mind, that while Guile-GI internally uses GOOPS, GObjects
implemented in it are not quite as flexible. For instance, you cannot
meaningfully redefine a GObject-based type, which you could if you just
used GOOPS types.  On the other hand, you can make use of the features
of the GObject infrastructure, such as signals.

Defining a new GObject class is rather complicated.

@deffn Procedure register-type type-name parent-type list-of-properties list-of-signals disposer
This procedure creates and returns a new @code{<GType>} of a GObject
object.

@var{type-name} is the string name of the new type. Note, that it will
be turned into a symbol internally.

@var{parent-type} is the @code{<GType>} of the parent class to this
class.  The parent class needs to be @code{<GObject>} or a GObject class
that descends from it.

@var{list-of-properties} is a list of parameter specifications.  These
parameter specifications can be created using the @code{param-spec-TYPE}
methods found in the @code{GObject} typelib.

@var{list-of-signals} is a list of signal specifications. @xref{GObject
Signals}.
@end deffn

To then make instances of your custom GObject type, use @code{make}.

@c ----------------------------------------------------------------
@node Enums and Flags
@section Enums and Flags
While GObject is an OOP framework and as such mainly focuses on objects,
there also exists functionality to deal with enumerated types.
Enumerated types are a way of converting raw numbers into meaningful
expressions and broadly fit into two categories: enumerations and flags.
Both assign tokens to numerical values at compile time, but their xuse
is different.  Enumerations are used for equality checks only, whereas
flags can be composed through bitwise or, tested by bitwise and, and
operated on in other ways -- as long as the basic operations are
bitwise, the result will make some sense.

In Scheme, the closest analogues to enumerations and flags are symbols
and symbol lists.  Symbol equality can be checked with @code{eq?},
symbol list equality with @code{equal?} and in Guile specifically, the
other operations can be implemented based on the @code{lset-*}
procedures.@footnote{Other implementations may offer similar functions
-- otherwise they can be implemented by the user themselves.}  However,
both of these lose information needed to convert them into a numerical
representation.

In Guile-GI, we bind enumerations and flags to GOOPS objects as we do
with every other object type. Specifically, enums derive from
@code{<GEnum>} and flags derive from @code{<GFlags>}.

@subsection Conversions
These procedures are defined in @code{(gi types)}.

@deffn Procedure number->enum (class <class>) (number <number>)
@deffnx Procedure number->enum (class <class>)
@deffnx Procedure number->flags (class <class>) (number <number>)
@deffnx Procedure number->flags (class <class>)
@deffnx Procedure number->@var{type} (number <number>)
Converts @var{number} into an enum or flags of class @var{class}.
Called with just @var{class}, produces a procedure, that can be used to
call itself with just @var{number}.This is often referred to as
currying.

number->@var{type} calls the appropriate constructor for the given
type. Note, that this type is shortened to its name without any
prefixes.  For instance, a @code{GtkOrientation} may be created using
@code{number->orientation}.  We will henceforth refer to this
construction as ``binding @var{class} on @var{type}''
@end deffn

@deffn Procedure enum-set->list (class <class>)
Returns a list of symbols that can be converted into enums of class
@var{class}.
@end deffn

@deffn Procedure symbol->enum (class <class>) (symbol <symbol>)
@deffnx Procedure symbol->enum (class <class>)
@deffnx Procedure symbol->var{type} (symbol <symbol>)
Converts @var{symbol} into an enum of class @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure list->flags (class <class>) (list <list>)
@deffnx Procedure list->flags (class <class>)
@deffnx Procedure list->var{type} (list <list>)
Converts @var{symbol} into flags of class @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure enum->number (enum <GEnum>)
@deffnx Procedure enum->number (class <class>) (enum <GEnum>)
@deffnx Procedure enum->number (class <class>) (symbol <symbol>)
@deffnx Procedure enum->number (class <class>)
@deffnx Procedure @var{type}->number (class <class>)
If @var{symbol} is given, returns the value represented by @var{symbol}
in @var{class}.

If @var{enum} is given, converts it to a symbol.
If both @var{enum} and @var{class} are given, raises an error
if @var{enum} is not of type @var{class}.

Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure enum->symbol (enum <GEnum>)
@deffnx Procedure enum->symbol (class <class>) (enum <GEnum>)
@deffnx Procedure enum->symbol (class <class>)
@deffnx Procedure @var{type}->symbol (class <class>)
Converts @var{enum} to a symbol. If @var{class} is given, raises an error
if @var{enum} is not of type @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure flags->number (enum <GEnum>)
@deffnx Procedure flags->number (class <class>) (enum <GEnum>)
@deffnx Procedure flags->number (class <class>) (list <list>)
@deffnx Procedure flags->number (class <class>)
@deffnx Procedure @var{type}->number (class <class>)
If @var{list} is given, returns the value represented by @var{list}
in @var{class}.

If @var{flags} is given, converts it to a symbol.
If both @var{flags} and @var{class} are given, raises an error
if @var{flags} is not of type @var{class}.

Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure flags-set->list (class <class>)
Returns a list of symbols that could represent flags of class
@var{class}.
@end deffn

@deffn Procedure flags->list (enum <GEnum>)
@deffnx Procedure flags->list (class <class>) (enum <GEnum>)
@deffnx Procedure flags->list (class <class>)
@deffnx Procedure @var{type}->list (class <class>)
Converts @var{flags} to a list of symbols. If @var{class} is given, raises an error
if @var{flags} is not of type @var{class}.
Curries. Binds @var{flags} on @var{type}.
@end deffn

@subsection Standard Procedure overrides
@code{<GEnum>} and @code{<GFlags>} display as their symbolic/list
representation and also use them in write in lieu of their addresses.
Enumerations can be numerically compared to enumerations and numbers
using @code{=}.  Flags can be numerically compared to flags and numbers
using @code{=}.  Enumerations and flags can be compared to enumerations
and flags of the same type using @code{equal?}.

@subsection R6RS-esque flag operations
Some would certainly like to see an equivalence the enumerated types
discussed above and R6RS enum sets. However, it turns out, that they are
not compatible.  Enumerations are not enum sets, because they are not
sets -- they are atoms.  Flags are not enum sets, because they don't
have a universe.  Instead, they have a numerical mask.  In an enum
universe, each value is distinct from any other. GObject flags can
however be combinations of other flags.  A commonly found pattern is
@code{SOME_READWRITE = SOME_READ | SOME_WRITE} for example.  Hiding
@code{'readwrite} would take a lot of work just so we can explicitly go
against the design of the library writer, which is not a good idea at
all.

To cope with this fact, we implement our own -- similar, albeit somewhat
different -- set of functions, that aim to be close to what you see in
R6RS.

@deffn Procedure flags-mask (class <class>)
@deffnx Procedure flags-mask (flags <GFlags>)
Returns flags of class @var{class}, that has all possible values set.
If @var{flags} is given, @var{class} is inferred from it.
@end deffn

@deffn Procedure flags-union (flags <GFlags>) . rest
Constructs the union of all flags given by @var{flags} and @var{rest}.
All of them must belong to the same class.
@end deffn

@deffn Procedure flags-intersection (flags <GFlags>) . rest
Constructs the intersection of all flags given by @var{flags} and @var{rest}.
All of them must belong to the same class.
@end deffn

@deffn Procedure flags-difference (flags1 <GFlags>) (flags2 <GFlags>)
Constructs the difference of @var{flags1} and @var{flags2}.
Both of them must belong to the same class.
@end deffn

@deffn Procedure flags-complement (flags <GFlags>)
Returns the flags not set in @var{flags}.
@end deffn

@deffn Procedure flags-set? (flags <GFlags>) (number <number>)
@deffnx Procedure flags-set? (flags <GFlags>) (symbol <symbol>)
@deffnx Procedure flags-set? (flags <GFlags>) (list <list>)
Return @var{#t} if and only if the flag(s) given by @var{number}, @var{symbol}
or @var{list} are set.
@end deffn

@deffn Procedure flags-projection
@deffnx Procedure flags-projection/list (flags <GFlags>) (class <class>)
@deffnx Procedure flags-projection/list (flags <GFlags>) (flags2 <GFlags>)
@deffnx Procedure flags-projection/number (flags <GFlags>) (class <class>)
@deffnx Procedure flags-projection/number (flags <GFlags>) (flags2 <GFlags>)
Project @var{flags} onto class @var{class}. (@var{class} is inferred from @var{flags2}).

@code{flags-projection/list} constructs flags from all symbols in
@code{(flags->symbol flags)}, that are valid in @code{class}.
@code{flags-projection/number} constructs flags, that have the same bits
set with respect to @code{(flags-mask class)}.

@code{flags-projection} is an alias for @code{flags-projection/list}.
@end deffn

@c ----------------------------------------------------------------
@node Utilities
@section Utilities
@cindex utilities

@deffn Procedure push-duplicate-handler! handler
Adds @var{handler} to the default duplicate handlers at the start of the list.
@end deffn

@findex shrug-equals
@defvr {Duplicate handler} shrug-equals
A handler, which silently accepts equal (as in @code{eq?}) bindings.
@end defvr

@deffn Procedure protect symbol [prefix] [suffix]
@deffnx Procedure protect* symbols [prefix] [suffix]
Returns a renamer, which ``protects'' @var{symbol}, a symbol or
@var{symbols}, a list of symbols from being overridden, by prepending
prefix and appending suffix, both symbols.  If neither prefix nor suffix
are given, @code{'%} is used as prefix.
@end deffn

@c ----------------------------------------------------------------
@node More Stuff
@section More Stuff

@subsection On Guile to C Type Conversions
Guile-GI uses a rule system to convert Guile procedure arguments to C
types.  Typically these conversions between Guile and C types are
straightforward, but, some conversions are tricky and need additional
description.

@subsubsection Strings
@cindex strings

GObject libraries usually use UTF-8 encoding for their strings, while
Guile uses a different encoding internally for its strings.  Thus
every time a string is parameter is passed through to a C procedure, a
new UTF-8 copy of the Guile string is created.  The string is
automatically freed when no longer in use.

GObject has some procedures that deal with locale-encoded strings:
notably those procedures that deal with environment variables.
Guile-GI converts Guile strings to locale-encoded strings for those
procedures.  Note that this may throw an encoding error if the Guile
string cannot be represented in the current locale.

@subsection C Arrays
@cindex arrays

There are many different types of C arrays, and the Guile types
expected for GObject procedures that C arrays varies depending on the
type required.

Typically, for simple C arrays of numerical types -- integers, floating
points, etc -- a Guile bytevector needs to be used.  For these
bytevectors, always use native-endianness.

For C arrays of GObject objects, structs, unions, flags, enums, and
GTypes, a @emph{list} is used instead of a bytevector.

If the C procedure expects a zero-terminated array, Guile-GI will
provide that automatically.  There is no need to add you own zero.

Some GObject procedures write output information into preallocated C
arrays.  For those procedures, the Guile caller will need to create
and pass in a bytevector of the appropriate size.

@quotation Warning
It is best not to use any of GLib's @code{Array} and @code{ByteArray}
procedures directly.  Since arrays get converted to bytevectors, these
procedures will likely fail to do anything sensible.
@end quotation

@subsection Help! Guile-GI overrides core binding X
In most cases this is nothing to worry about. Guile-GI ensures, that
the core binding is used as the default behaviour when the signature
does not accidentally match that of a function in some typelib.
However, this can still cause issues when Guile-GI overrides syntax.
To protect your syntax (or other variables you deeply care about), use
the @code{protect} or @code{protect*} renamer from @code{(gi util)}.

@subsection Help! Guile-GI bindings conflict with each other
@findex merge-generics
@findex shrug-equals

Most conflicts should be resolved using the @code{merge-generics}
duplicate handler.  However, this handler is not enabled by default, so
you may want to push it to the default duplicate handlers. If this is
still not working, you may somehow have ended up with ``equal''
duplicates, i.e. duplicates, whose bindings resolve to the same value.
To silence warnings about them, use the @code{shrug-equals} duplicate
handler defined in @code{(gi util)}.  If the conflict is still not
resolved, file a bug detailing it.  As a workaround, you may also rename
either binding, which is probably the best way to resolve a duplicate.

@node Further Resources and Contact Info
@chapter Further Resources and Contact Info

Uh, I dunno.

Maybe the Guile mailing list?

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@node Index
@unnumbered Index

@printindex cp

@bye
